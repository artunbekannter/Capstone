from abc import ABC, abstractmethod
import random
from maze2 import Maze

class GameEntity(ABC):
    def __init__(self, x, y, icon):
        self.x = x
        self.y = y
        self.icon = icon # These become relevant in the entities. We can initiate self, x, y and provide an icon.
           
    def move(self, dx, dy): #T Think of dx and dy as DIRECTION X or DIRECTION Y.
        self.x += dx # We are adding self position and DIRECTION X to move.
        self.y += dy # We are adding self position and DIRECTION Y to move. It's kinda like plotting on a grid chart.
    
    def get_position(self):
        return self.x, self.y # We are returning the position of self. So basically give back the values, return them to be. Return the Ring to Mordor. Etc.
        
        
class Player(GameEntity):
    def __init__(self, x, y):
        super().__init__(x, y, "P") # We are basically saying that the player exists as a child class of GameEntity and uses x, y coordinates and is represented by P. This allows it to use move, and get_position.
        
class Wall(GameEntity):
    def __init__(self, x, y):
        super().__init__(x, y, "#") # Technically not using this entity because it's already generated by the maze. But we could use it by modifying the code (I just haven't entirely figured out how).
        
class Exit(GameEntity):
    def __init__(self, x, y):
        super().__init__(x, y, "E") # Same applies here.